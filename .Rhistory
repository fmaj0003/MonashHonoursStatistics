ex.data.2 <- data.table(
ID = factor(rep(1:4, each = 10)),
time = rep(1:10, times = 4),
y = rnorm(40, 2.5, 1))
ggarrange(
set_palette(ggplot(ex.data.1,
aes(time, y, colour = ID, shape = ID)) +
stat_smooth(method = "lm", formula = y ~ 1, se=FALSE) +
geom_point() +
theme_pubr(), "jco"),
set_palette(ggplot(ex.data.2,
aes(time, y, colour = ID, shape = ID)) +
stat_smooth(method = "lm", formula = y ~ 1, se=FALSE) +
geom_point() +
theme_pubr(), "jco"),
ncol = 1,
labels = c("High Between", "Low Between"))
iccMixed("dStress", id = "ID", data = dd)
iccMixed("dEnergy", id = "ID", data = dd)
DiagrammeR::grViz("
digraph 'Decomposing multilevel effects' {
graph [overlap = true, fontsize = 14]
node [fontname = Helvetica, shape = rectangle]
T [label = 'Total']
B [label = 'Between']
W [label = 'Within']
T -> {B W}
}
")
DiagrammeR::grViz("
digraph 'Decomposing multilevel effects example' {
graph [overlap = true, fontsize = 12]
node [fontname = Helvetica, shape = rectangle]
subgraph Between {
node [fontname = Helvetica, shape = rectangle]
B1 [label = 'Day 1: 3']
B2 [label = 'Day 2: 3']
B3 [label = 'Day 3: 3']
B1 -> B2
B2 -> B3
}
subgraph Within {
node [fontname = Helvetica, shape = rectangle]
W1 [label = 'Day 1: -2']
W2 [label = 'Day 2: 0']
W3 [label = 'Day 3: +2']
W1 -> W2
W2 -> W3
}
Total
Total -> Between
Total -> Within
Between -> B1 [lhead = between]
Within  -> W1 [lhead = within]
}
")
m  <- lmer(dStress ~ 1 + (1 | ID), data = dd)
summary(m)
fixef(m)
coef(m)
## make a data table of the random intercepts and IDs
randomintercept <- data.table(
ID = as.numeric(rownames(coef(m)$ID)),
RI = coef(m)$ID[, "(Intercept)"])
## view the first few rows
head(randomintercept)
## calculate the means and number of observations, by ID
individualMeans <- dd[!is.na(dStress), .(
Means = mean(dStress),
N = .N), by = ID]
## merge the two datasets together by ID
rimeans <- merge(randomintercept, individualMeans, by = "ID", all=FALSE)
## order the dataset by mean
rimeans <- rimeans[order(Means)]
rimeans[, ID := factor(ID, levels = ID)]
## view the merged data
head(rimeans)
ggplot(rimeans, aes(ID, xend = ID, y = Means, yend = RI, colour = N)) +
geom_hline(yintercept = fixef(m)[["(Intercept)"]]) +
geom_segment(arrow = arrow(length = unit(.15, "cm"))) +
coord_flip() +
theme_pubr() +
ggtitle("Shrinkage From Raw to LMM Means")
md <- modelDiagnostics(m, ev.perc = .001)
## check the R class of stress
class(dd$dStress)
## convert stress in R to a numeric class
dd[, dStress := as.numeric(dStress)]
## refit model
m  <- lmer(dStress ~ 1 + (1 | ID), data = dd)
## calculate diagnostics
md <- modelDiagnostics(m, ev.perc = .001)
## plot diagnostics
plot(md, ask = FALSE, ncol = 2, nrow = 2)
?read_sav
options(digits = 2)
## There are two new packages: (1) mice (2) VIM
## both are used for missing data.
## some people have reported also needing the zip pkg
# install.packages("zip") before the other packages install correctly
library(data.table)
library(JWileymisc)
library(mice)
library(VIM)
library(ggplot2)
set.seed(12345)
x <- data.frame(Age = sort(round(runif(10, 30, 65))))
x$Inflammation <-  rnorm(10, x$Age/10, sd = .2)
x$Missing <- as.logical(rep(FALSE:TRUE, c(9, 1))) # first indicate which (one) data point will be missing by creating a var called "missing"
scatterp <- ggplot(x, aes(Age, Inflammation)) +
stat_smooth(method = "lm", formula = y ~ x, se=FALSE) +
geom_point(aes(colour = Missing, size = Missing)) +
theme_classic() + theme(legend.position = c(.8, .2))
print(scatterp)
## create a missing dataset (i.e., where we said we wanted the missing data to be, replace the value of inflammation with NA)
y <- x
y$Inflammation[y$Missing] <- NA
## create an imputed dataset
yimp <- y
p <- vector("list", length = 10)
imps <- vector("numeric", length = 10)
# the first loop (i==1) uses the median, then subsequent loops build a linear model from the last loop (and extrapolate the next loop's missing value from that model)
for (i in 1:10) {
if (i == 1) {
imps[i] <- median(y$Inflammation, na.rm = TRUE)
} else if (i > 1) {
m <- lm(Inflammation ~ Age, data = yimp)
imps[i] <- fitted(m)[yimp$Missing]
}
yimp$Inflammation[yimp$Missing == TRUE] <- imps[i]
p[[i]] <- scatterp %+% yimp + ggtitle(sprintf("Iteration = %d", i))
if (i > 4) {
p[[i]] <- p[[i]] + coord_cartesian(xlim = c(55, 66), ylim = c(5.4, 7), expand=FALSE)
}
print(p[[i]]) # what we're printing here is a scatterplot of each loop
}
print(imps, digits = 5)
## read in the dataset
data(aces_daily)
d <- as.data.table(aces_daily)
## between person data, no missing - using the na.omit function
davg <- na.omit(d[, .(
Female = factor(na.omit(Female)[1], levels = 0:1),
Age = na.omit(Age)[1],
STRESS = mean(STRESS, na.rm = TRUE),
PosAff = mean(PosAff, na.rm = TRUE),
NegAff = mean(NegAff, na.rm = TRUE)),
by = UserID])
## create missing data
davgmiss <- copy(davg)
davgmiss[STRESS < 1, NegAff := NA]
davgmiss[STRESS > 4, PosAff := NA]
## random missingness on age and Female
set.seed(1234)
davgmiss[rbinom(.N, size = 1, prob = .1) == 1, Age := NA_real_]
davgmiss[rbinom(.N, size = 1, prob = .05) == 1, Female := NA]
## drop unneeded variables to make analysis easier
davgmiss[, UserID := NULL]
aggr(davgmiss, prop = TRUE,
numbers = TRUE)
marginplot(davgmiss[,.(STRESS, NegAff)])
## does stress differ by missing on negative affect? (Spoiler: we literally told it to earlier!)
t.test(STRESS ~ is.na(NegAff), data = davgmiss)
## does stress differ by missing on positive affect?
t.test(STRESS ~ is.na(PosAff), data = davgmiss)
## does age differ by missing on negative affect?
t.test(Age ~ is.na(NegAff), data = davgmiss)
## does age differ by missing on positive affect?
t.test(Age ~ is.na(PosAff), data = davgmiss)
chisq.test(davgmiss$Female, is.na(davgmiss$PosAff))
chisq.test(davgmiss$Female, is.na(davgmiss$NegAff))
options(digits = 2)
## There are two new packages: (1) mice (2) VIM
## both are used for missing data.
## some people have reported also needing the zip pkg
# install.packages("zip") before the other packages install correctly
library(data.table)
library(JWileymisc)
library(mice)
library(VIM)
library(ggplot2)
set.seed(12345)
x <- data.frame(Age = sort(round(runif(10, 30, 65))))
x$Inflammation <-  rnorm(10, x$Age/10, sd = .2)
x$Missing <- as.logical(rep(FALSE:TRUE, c(9, 1))) # first indicate which (one) data point will be missing by creating a var called "missing"
scatterp <- ggplot(x, aes(Age, Inflammation)) +
stat_smooth(method = "lm", formula = y ~ x, se=FALSE) +
geom_point(aes(colour = Missing, size = Missing)) +
theme_classic() + theme(legend.position = c(.8, .2))
print(scatterp)
## create a missing dataset (i.e., where we said we wanted the missing data to be, replace the value of inflammation with NA)
y <- x
y$Inflammation[y$Missing] <- NA
## create an imputed dataset
yimp <- y
p <- vector("list", length = 10)
imps <- vector("numeric", length = 10)
# the first loop (i==1) uses the median, then subsequent loops build a linear model from the last loop (and extrapolate the next loop's missing value from that model)
for (i in 1:10) {
if (i == 1) {
imps[i] <- median(y$Inflammation, na.rm = TRUE)
} else if (i > 1) {
m <- lm(Inflammation ~ Age, data = yimp)
imps[i] <- fitted(m)[yimp$Missing]
}
yimp$Inflammation[yimp$Missing == TRUE] <- imps[i]
p[[i]] <- scatterp %+% yimp + ggtitle(sprintf("Iteration = %d", i))
if (i > 4) {
p[[i]] <- p[[i]] + coord_cartesian(xlim = c(55, 66), ylim = c(5.4, 7), expand=FALSE)
}
print(p[[i]]) # what we're printing here is a scatterplot of each loop
}
print(imps, digits = 5)
## read in the dataset
data(aces_daily)
d <- as.data.table(aces_daily)
## between person data, no missing - using the na.omit function
davg <- na.omit(d[, .(
Female = factor(na.omit(Female)[1], levels = 0:1),
Age = na.omit(Age)[1],
STRESS = mean(STRESS, na.rm = TRUE),
PosAff = mean(PosAff, na.rm = TRUE),
NegAff = mean(NegAff, na.rm = TRUE)),
by = UserID])
## create missing data
davgmiss <- copy(davg)
davgmiss[STRESS < 1, NegAff := NA]
davgmiss[STRESS > 4, PosAff := NA]
## random missingness on age and Female
set.seed(1234)
davgmiss[rbinom(.N, size = 1, prob = .1) == 1, Age := NA_real_]
davgmiss[rbinom(.N, size = 1, prob = .05) == 1, Female := NA]
## drop unneeded variables to make analysis easier
davgmiss[, UserID := NULL]
aggr(davgmiss, prop = TRUE,
numbers = TRUE)
marginplot(davgmiss[,.(STRESS, NegAff)])
## does stress differ by missing on negative affect? (Spoiler: we literally told it to earlier!)
t.test(STRESS ~ is.na(NegAff), data = davgmiss)
## does stress differ by missing on positive affect?
t.test(STRESS ~ is.na(PosAff), data = davgmiss)
## does age differ by missing on negative affect?
t.test(Age ~ is.na(NegAff), data = davgmiss)
## does age differ by missing on positive affect?
t.test(Age ~ is.na(PosAff), data = davgmiss)
chisq.test(davgmiss$Female, is.na(davgmiss$PosAff))
chisq.test(davgmiss$Female, is.na(davgmiss$NegAff))
mi.1 <- mice(
davgmiss,
m = 5,   maxit = 3,
defaultMethod = c("norm", "logreg", "polyreg", "polr"),
seed = 1234, printFlag = FALSE)
## plot convergence diagnostics
plot(mi.1, PosAff + NegAff + Female ~ .it | .ms)
View(mi.1)
options(digits = 2)
## There are two new packages: (1) mice (2) VIM
## both are used for missing data.
## some people have reported also needing the zip pkg
# install.packages("zip") before the other packages install correctly
library(data.table)
library(JWileymisc)
library(mice)
library(VIM)
library(ggplot2)
set.seed(12345)
x <- data.frame(Age = sort(round(runif(10, 30, 65))))
x$Inflammation <-  rnorm(10, x$Age/10, sd = .2)
x$Missing <- as.logical(rep(FALSE:TRUE, c(9, 1))) # first indicate which (one) data point will be missing by creating a var called "missing"
scatterp <- ggplot(x, aes(Age, Inflammation)) +
stat_smooth(method = "lm", formula = y ~ x, se=FALSE) +
geom_point(aes(colour = Missing, size = Missing)) +
theme_classic() + theme(legend.position = c(.8, .2))
print(scatterp)
## create a missing dataset (i.e., where we said we wanted the missing data to be, replace the value of inflammation with NA)
y <- x
y$Inflammation[y$Missing] <- NA
## create an imputed dataset
yimp <- y
p <- vector("list", length = 10)
imps <- vector("numeric", length = 10)
# the first loop (i==1) uses the median, then subsequent loops build a linear model from the last loop (and extrapolate the next loop's missing value from that model)
for (i in 1:10) {
if (i == 1) {
imps[i] <- median(y$Inflammation, na.rm = TRUE)
} else if (i > 1) {
m <- lm(Inflammation ~ Age, data = yimp)
imps[i] <- fitted(m)[yimp$Missing]
}
yimp$Inflammation[yimp$Missing == TRUE] <- imps[i]
p[[i]] <- scatterp %+% yimp + ggtitle(sprintf("Iteration = %d", i))
if (i > 4) {
p[[i]] <- p[[i]] + coord_cartesian(xlim = c(55, 66), ylim = c(5.4, 7), expand=FALSE)
}
print(p[[i]]) # what we're printing here is a scatterplot of each loop
}
print(imps, digits = 5)
## read in the dataset
data(aces_daily)
d <- as.data.table(aces_daily)
## between person data, no missing - using the na.omit function
davg <- na.omit(d[, .(
Female = factor(na.omit(Female)[1], levels = 0:1),
Age = na.omit(Age)[1],
STRESS = mean(STRESS, na.rm = TRUE),
PosAff = mean(PosAff, na.rm = TRUE),
NegAff = mean(NegAff, na.rm = TRUE)),
by = UserID])
## create missing data
davgmiss <- copy(davg)
davgmiss[STRESS < 1, NegAff := NA]
davgmiss[STRESS > 4, PosAff := NA]
## random missingness on age and Female
set.seed(1234)
davgmiss[rbinom(.N, size = 1, prob = .1) == 1, Age := NA_real_]
davgmiss[rbinom(.N, size = 1, prob = .05) == 1, Female := NA]
## drop unneeded variables to make analysis easier
davgmiss[, UserID := NULL]
aggr(davgmiss, prop = TRUE,
numbers = TRUE)
marginplot(davgmiss[,.(STRESS, NegAff)])
## does stress differ by missing on negative affect? (Spoiler: we literally told it to earlier!)
t.test(STRESS ~ is.na(NegAff), data = davgmiss)
## does stress differ by missing on positive affect?
t.test(STRESS ~ is.na(PosAff), data = davgmiss)
## does age differ by missing on negative affect?
t.test(Age ~ is.na(NegAff), data = davgmiss)
## does age differ by missing on positive affect?
t.test(Age ~ is.na(PosAff), data = davgmiss)
chisq.test(davgmiss$Female, is.na(davgmiss$PosAff))
chisq.test(davgmiss$Female, is.na(davgmiss$NegAff))
mi.1 <- mice(
davgmiss,
m = 5,   maxit = 3,
defaultMethod = c("norm", "logreg", "polyreg", "polr"),
seed = 1234, printFlag = FALSE)
## plot convergence diagnostics
plot(mi.1, PosAff + NegAff + Female ~ .it | .ms)
## run an additional iterations
mi.1 <- mice.mids(
mi.1, maxit = 20,
printFlag = FALSE)
## plot convergence diagnostics
plot(mi.1, PosAff + NegAff + Female ~ .it | .ms)
densityplot(mi.1, ~ PosAff + NegAff + Age)
xyplot(mi.1, NegAff + PosAff ~ STRESS)
mi.reg <- with(mi.1, lm(NegAff ~ PosAff + Age))
mi.reg
pool(mi.reg)
library(haven)
# Which library do we need to open the daily diary as a data table?
library(data.table)
# Which three libraries did we need in the readings for mixed effect models?
library(lme4)
library(lmerTest)
library(multilevelTools)
# You will also need:
library(JWileymisc)
library(visreg)
library(ggplot2)
library(ggpubr)
library(tufte)
setwd("/Users/farhan/Git Repos/MonashHonoursStatistics")
dd <- as.data.table(read_sav("[2021] PSY4210 DD.sav")) # daily diary
m  <- lmer(dEnergy ~ 1 + (1 | ID), data = dd)
summary(m)
summary(m)
View(m)
View(dd)
View(dd)
library(haven)
# Which library do we need to open the daily diary as a data table?
library(data.table)
# Which three libraries did we need in the readings for mixed effect models?
library(lme4)
library(lmerTest)
library(multilevelTools)
# You will also need:
library(JWileymisc)
library(visreg)
library(ggplot2)
library(ggpubr)
library(tufte)
# Set your working directory to the folder that has the DD dataset
setwd("/Users/farhan/Git Repos/MonashHonoursStatistics")
# Load in the daily diary dataset and convert it to a data table
dd <- as.data.table(read_sav("[2021] PSY4210 DD.sav")) # daily diary
View(dd)
setwd("/Users/farhan/Git Repos/MonashHonoursStatistics")
# Load in the daily diary dataset and convert it to a data table
dd <- as.data.table(read_sav("[2021] PSY4210 DD.sav")) # daily diary
View(dd)
setwd("/Users/farhan/Git Repos/MonashHonoursStatistics")
# Load in the daily diary dataset and convert it to a data table
dd <- as.data.table(read_sav("[2021] PSY4210 DD.sav")) # daily diary
View(dd)
m  <- lmer(dEnergy ~ 1 + (1 | ID), data = dd)
summary(m)
dd[, dEnergy := as.numeric(dEnergy)]
# First, make a between (BEnergy) and within (WEnergy) variable of dEnergy:
dd[!is.na(ID), c("BEnergy", "WEnergy") := meanDeviations(dEnergy), by = ID]
head(dd[!is.na(ID), .(BEnergy, WEnergy, dEnergy, ID)])
dd2 <- dd[!is.na(ID)] #removing the NA ID values once and for all
testDistribution(dd2$WEnergy,
extremevalues = "theoretical", ev.perc = .005)$Data[isEV == "Yes"]
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.noev <- dd2[-c(265, 8, 87, 194, 201, 153)]
?haven
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.noev <- dd2[-c(265, 8, 87, 194, 201, 153)]
plot(testDistribution(dd.noev$WEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Within Energy (WEnergy)")
q()
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
# Which library do we need for the read_sav function?
library(haven)
# Which library do we need to open the daily diary as a data table?
library(data.table)
# Which three libraries did we need in the readings for mixed effect models?
library(lme4)
library(lmerTest)
library(multilevelTools)
# You will also need:
library(JWileymisc)
library(visreg)
library(ggplot2)
library(ggpubr)
library(tufte)
# Set your working directory to the folder that has the DD dataset
setwd("/Users/farhan/Git Repos/MonashHonoursStatistics")
# Load in the daily diary dataset and convert it to a data table
dd <- as.data.table(read_sav("[2021] PSY4210 DD.sav")) # daily diary
# Build a random intercept model predicting 'dEnergy'.
m  <- lmer(dEnergy ~ 1 + (1 | ID), data = dd)
summary(m)
# Q: On average, these people had an energy score of 4.02
# A: ???
# Bonus: find a second way in the code to just display the answer above:
fixef(m)
# Try to clean the within and between level of the variable:
#  `dEnergy` in the daily dataset with missing IDs removed,
# `dd2`.
dd[, dEnergy := as.numeric(dEnergy)]
# First, make a between (BEnergy) and within (WEnergy) variable of dEnergy:
dd[!is.na(ID), c("BEnergy", "WEnergy") := meanDeviations(dEnergy), by = ID]
head(dd[!is.na(ID), .(BEnergy, WEnergy, dEnergy, ID)])
# Second, assess distribution of within energy.
# If needed, excluded rows / IDs (make extreme value threshold 0.5%).
plot(testDistribution(dd[!is.na(ID)]$WEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Within Energy (WEnergy)")
dd2 <- dd[!is.na(ID)] #removing the NA ID values once and for all
testDistribution(dd2$WEnergy,
extremevalues = "theoretical", ev.perc = .005)$Data[isEV == "Yes"]
# Show and remove the outliers based on row number ("OriginalOrder"):
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.noev <- dd2[-c(265, 8, 87, 194, 201, 153)]
plot(testDistribution(dd.noev$WEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Within Energy (WEnergy)")
dd.noev[, c("BEnergy", "WEnergy") := meanDeviations(dEnergy), by = ID]
# Make a dataset with only one row of data per person to clean the between level
dd.b <- dd.noev[!duplicated(ID)]
# Examine the distribution of the between level and remove any outliers/IDs
plot(testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Between Energy (BEnergy)")
testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005)$Data[isEV == "Yes"]
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.noev <- dd2[-c(265, 8, 87, 194, 201, 153)]
plot(testDistribution(dd.noev$WEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Within Energy (WEnergy)")
# Now recreate between and within levels of energy on the dataset
# without extreme within values.
dd.noev[, c("BEnergy", "WEnergy") := meanDeviations(dEnergy), by = ID]
# Make a dataset with only one row of data per person to clean the between level
dd.b <- dd.noev[!duplicated(ID)]
# Examine the distribution of the between level and remove any outliers/IDs
plot(testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Between Energy (BEnergy)")
testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005)$Data[isEV == "Yes"]
dd.b[c(83), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.b.noev <- dd.b[-c(83)]
plot(testDistribution(dd.b.noev$BEnergy,
extremevalues = "theoretical", ev.perc = ???),
dd2[c(265, 8, 87, 194, 201, 153), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.noev <- dd2[-c(265, 8, 87, 194, 201, 153)]
plot(testDistribution(dd.noev$WEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Within Energy (WEnergy)")
# Now recreate between and within levels of energy on the dataset
# without extreme within values.
dd.noev[, c("BEnergy", "WEnergy") := meanDeviations(dEnergy), by = ID]
# Make a dataset with only one row of data per person to clean the between level
dd.b <- dd.noev[!duplicated(ID)]
# Examine the distribution of the between level and remove any outliers/IDs
plot(testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Between Energy (BEnergy)")
testDistribution(dd.b$BEnergy,
extremevalues = "theoretical", ev.perc = .005)$Data[isEV == "Yes"]
dd.b[c(83), .(dEnergy, BEnergy, WEnergy, SurveyDay, ID)]
dd.b.noev <- dd.b[-c(83)]
plot(testDistribution(dd.b.noev$BEnergy,
extremevalues = "theoretical", ev.perc = .005),
varlab = "Between Energy (BEnergy)")
